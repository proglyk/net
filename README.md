### Назначение

Единый сетевой слой для Cortex-M: поднимает Ethernet/LwIP, ведёт задачи серверов и клиентов, разруливает подключения и разрывы, отдаёт удобное API приложению.

### Ключевые узлы

<img src="http://github.com/proglyk/net/raw/main/image/diagram_NET_EN.png" width="500" height="305">

#### net.c / net.h - Верхний оркестратор

Содержит функции:

* net__init() — инициализация LwIP (tcpip_init) и сетевого интерфейса (net_netif__init() с колбэком линка).

* net__run() — запуск диспетчеров: клиентов, серверов и input-задачи интерфейса.

* net__add_srv() / net__add_clt() — регистрация серверов/клиентов по структуре net_init_t.

* net__input() — сигнал сетевому интерфейсу о новом кадре (разблокирует input-задачу).

* net__irq() — проброс IRQ Ethernet-MAC в низкий уровень.

* net__inst() — синглтон net_t.

#### net_netif.c / .h - Слой сетевого интерфейса LwIP

Выполнят задачи:

* Создаёт struct netif, настраивает output/input (ETHARP/ethernet_input).

* Поддерживает DHCP-клиент.

* Задача task_input: ждёт семафор и скармливает кадры стеку (net_eth__input()).

* Колбэк линка сообщает в net.c; при смене состояния обновляется флаг для диспетчеров, при down закрываются все серверы

#### net_eth.c / .h — MAC/PHY

Выполнят задачи:

* Инициализация/старт/стоп, IRQ-обслуживание, передача (net_eth__output) и приём (net_eth__input) pbuf-ов.

* Работа с DMA-дескрипторами HAL

#### net_srv.c / .h — серверы (TCP)

Выполнят задачи:

* Диспетчер просматривает список зарегистрированных серверов, при поднятом линке и флаге enable выполняет setup() (создание listening-сокета) и запускает thread_pool.

* thread_pool в цикле делает accept() и на каждого клиента поднимает отдельную FreeRTOS-задачу net_conn__do (до RMT_CLT_MAX штук).

* Есть net_srv__enable/disable/is_enabled и net_srv__delete_all()

#### net_clt.c / .h — клиенты (TCP/UDP)

Выполнят задачи:

* Диспетчер перебирает зарегистрированные клиенты; при поднятом интерфейсе и флаге enable выполняет try_connect() (TCP connect или подготовка UDP).

* После соединения поднимает задачу net_conn__do() с контекстом клиента.

#### net_conn.c / .h — логика сессии поверх сокета

Выполнят задачи:

* Единый раннер net_conn__do():

    1. вызывает ppvSessInit() верхнего уровня и получает пользовательский контекст,

    2. гоняет основной цикл pslSessDo() (чтение/обработка протокола),

    3. выполняет pvSessDel() для очистки.

* Таким образом протокол задаётся набором колбэков net_if_fn_t

#### net_if.h — контракт с «верхом»

Выполнят задачи:

* net_if_fn_t: указатели на функции ppvSessInit, pslSessDo, pvSessDel + опциональные колбэки уведомлений.

* net_init_t — единая структура регистрации сервера/клиента: имя, порт, тип сокета (CLT_TCP/CLT_UDP), флаг bEnabled, для клиента — pcRmt (IP), ulId, для сервера — pvTopPld


### Конкурентность и события

* FreeRTOS: отдельные задачи — диспетчер серверов, диспетчер клиентов, input-задача интерфейса, задачи сессий по одному на подключение.

* Семафоры/IRQ: прерывание ETH вызывает net__irq(), драйвер сигналит семафор pvSmphrInput, input-задача читает кадр и отдаёт его в LwIP.

* Состояние линка: колбэк в net.c хранит предыдущее состояние, при смене обновляет флаги и гасит все серверы при down.


### Ограничения/конфигурация

* Лимиты по конфигу (proj_conf.h): CLT_NUM_MAX = 4, SRV_NUM_MAX = 4, RMT_CLT_MAX = 4.

* Параметры платы, MAC/IP, выбор цели через #define-ы.

* При поиске свободного слота сервер/клиент определяется пустым именем в таблице.


### Как этим пользоваться (минимум шагов)

1. Вызвать net__init(&net).
2. Зарегистрировать сервера и/или клиентов через net__add_srv() / net__add_clt() с заполненным net_init_t и своим набором функций net_if_fn_t.
2. Запустить net__run(&net) — поднимутся диспетчеры и input-поток; дальше стек сам создаёт задачи сессий по мере подключений/соединений.


### Итог
Модуль net — аккуратная прослойка между аппаратным ETH и прикладным протоколом. Вся специфичная логика протокола выносится в набор функций net_if_fn_t, остальное — управление сокетами, жизненным циклом задач и транспортом.

```
Текст сгенерирован с помощью ChatGPT
```
